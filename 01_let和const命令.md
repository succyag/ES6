### let 命令

- `for`循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
- 在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
- 使用`let`声明变量时，只要变量在还没有声明完成前使用，就会报错。
- 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
- `let`不允许在相同作用域内，重复声明同一个变量。

### 块级作用域

- ES5 只有全局作用域和函数作用域，没有块级作用域。
- 内层作用域可以定义外层作用域的同名变量。
- ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
- ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。
- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
- `let`只能出现在当前作用域的顶层
- 严格模式下，函数只能声明在当前作用域的顶层。

### const 命令

- `const`声明的变量不得改变值，这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。
- `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。
- `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
- `const`声明的常量，也与`let`一样不可重复声明。

### 顶层对象的属性

- 顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。ES5 之中，顶层对象的属性与全局变量是等价的。
- `let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。

### golbalThis 对象

- [ES2020](https://github.com/tc39/proposal-global) 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。